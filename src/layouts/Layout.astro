---
// Import main CSS for styling
import '../index.css';
import '../styles/integrations-animations.css';
import '../styles/image-performance.css';
import ScailUpHeader from '../components/active/shared/ScailUpHeader';
import TrackingScript from '../components/TrackingScript.astro';
import Analytics from '../components/Analytics.astro';
import { ViewTransitions } from 'astro:transitions';
import { getImage } from 'astro:assets';
import heroImage from '../../public/hero-bg-buildrs-8k.webp';
import platformDashboard from '../../public/platform-dashboard-fullwidth.webp';

export interface Props {
  title: string;
  description?: string;
  keywords?: string;
  structuredData?: object;
}

const { title, description, keywords, structuredData } = Astro.props;

// Generate optimized image URLs for preloading
const optimizedHero = await getImage({ src: heroImage, format: 'webp', quality: 90, width: 1920 });
const optimizedPlatform = await getImage({ src: platformDashboard, format: 'webp', quality: 90, width: 1920 });
---

<!DOCTYPE html>
<html lang="nl" style="margin: 0 !important; padding: 0 !important; height: 100% !important; background-color: #000000 !important;">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  
  <!-- ULTRA-CRITICAL: Aggressive preloading - All above-fold content -->
  <link rel="preload" href="/hero-bg-buildrs-thumb.webp" as="image" fetchpriority="high" />
  <link rel="preload" href="/hero-bg-buildrs-8k.webp" as="image" fetchpriority="high" />
  <link rel="preload" href="/lead-generation-hero-optimized.webp" as="image" fetchpriority="high" />
  <link rel="preload" href={optimizedPlatform.src} as="image" fetchpriority="high" />
  
  <!-- CRITICAL: Preload ALL fonts immediately -->
  <link rel="preload" href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" as="style">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap">
  
  <!-- AGGRESSIVE: Preconnect to all external domains immediately -->
  <link rel="preconnect" href="https://cdn.simpleicons.org" crossorigin />
  <link rel="preconnect" href="https://logo.clearbit.com" crossorigin />
  <link rel="preconnect" href="https://res.cloudinary.com" crossorigin />
  <link rel="preconnect" href="https://fonts.googleapis.com" crossorigin />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  
  <!-- Prefetch critical JavaScript modules -->
  <link rel="modulepreload" href="/src/components/active/agency/HomeHero.tsx" />
  <link rel="modulepreload" href="/src/components/active/agency/SalesEngineSection.tsx" />
  <link rel="modulepreload" href="/src/components/active/agency/MarketingEngineSection.tsx" />
  
  <!-- CRITICAL: Anti-flicker scroll manager -->
  <script>
    // Ultra-smooth scroll optimization with anti-flicker
    (function() {
      let isScrolling = false;
      let scrollTimer = null;
      let lastScrollY = 0;
      let scrollVelocity = 0;
      
      function handleScroll() {
        const currentScrollY = window.scrollY;
        const currentTime = Date.now();
        
        if (!isScrolling) {
          isScrolling = true;
          document.documentElement.classList.add('fast-scrolling');
          document.documentElement.classList.remove('scroll-stable');
        }
        
        // Calculate scroll velocity
        const scrollDelta = Math.abs(currentScrollY - lastScrollY);
        scrollVelocity = scrollDelta;
        
        // If fast scrolling, disable transitions
        if (scrollVelocity > 50) {
          document.documentElement.classList.add('fast-scrolling');
        }
        
        lastScrollY = currentScrollY;
        
        // Clear existing timer
        clearTimeout(scrollTimer);
        
        // Set timer to detect scroll end
        scrollTimer = setTimeout(() => {
          isScrolling = false;
          document.documentElement.classList.remove('fast-scrolling');
          document.documentElement.classList.add('scroll-stable');
          
          // Remove scroll-stable class after transitions complete
          setTimeout(() => {
            document.documentElement.classList.remove('scroll-stable');
          }, 500);
        }, 100);
      }
      
      // Add scroll listener with passive for better performance
      window.addEventListener('scroll', handleScroll, { passive: true });
    })();
  </script>

  <!-- CRITICAL: Smart scroll restoration - fresh visit vs refresh -->
  <script>
    // Disable browser scroll restoration
    try {
      if ('scrollRestoration' in history) {
        history.scrollRestoration = 'manual';
      }
    } catch(e) {}
    
    // Smart scroll restoration with navigation type detection
    (function() {
      const STORAGE_KEY = 'buildrs_scroll_pos';
      const URL_KEY = 'buildrs_scroll_url';
      const VISIT_TYPE_KEY = 'buildrs_visit_type';
      
      // Detect navigation type
      function getNavigationType() {
        // Modern API
        if (performance.navigation) {
          return performance.navigation.type;
        }
        // Fallback for older browsers
        if (performance.getEntriesByType) {
          const navEntries = performance.getEntriesByType('navigation');
          if (navEntries.length > 0) {
            const navType = navEntries[0].type;
            if (navType === 'navigate') return 0;
            if (navType === 'reload') return 1;
            if (navType === 'back_forward') return 2;
          }
        }
        return 0; // Default to fresh visit
      }
      
      const navigationType = getNavigationType();
      const currentUrl = location.href;
      const savedPosition = sessionStorage.getItem(STORAGE_KEY);
      const savedUrl = sessionStorage.getItem(URL_KEY);
      
      // Determine if this is a fresh visit or refresh
      const isFreshVisit = navigationType === 0; // TYPE_NAVIGATE
      const isRefresh = navigationType === 1;     // TYPE_RELOAD  
      const isBackForward = navigationType === 2; // TYPE_BACK_FORWARD
      
      // Store visit type for debugging
      sessionStorage.setItem(VISIT_TYPE_KEY, navigationType.toString());
      
      // Only restore scroll position if:
      // 1. NOT a fresh visit AND
      // 2. We have a saved position AND  
      // 3. URL matches AND
      // 4. Position is valid
      const shouldRestore = !isFreshVisit && 
                           savedPosition && 
                           savedUrl === currentUrl &&
                           parseInt(savedPosition, 10) > 0;
      
      if (shouldRestore) {
        const targetPosition = parseInt(savedPosition, 10);
        if (Number.isFinite(targetPosition)) {
          // INSTANT scroll restore for refresh/back
          document.documentElement.scrollTop = targetPosition;
          window.scrollTo(0, targetPosition);
          document.documentElement.classList.add('scroll-restored');
        }
      } else if (isFreshVisit) {
        // Clear stale scroll data on fresh visits
        sessionStorage.removeItem(STORAGE_KEY);
        sessionStorage.removeItem(URL_KEY);
        // Ensure we start at top
        document.documentElement.scrollTop = 0;
        window.scrollTo(0, 0);
      }
    })();
    
    // Simplified scroll position saving for session tracking
    (function() {
      const STORAGE_KEY = 'buildrs_scroll_pos';
      const URL_KEY = 'buildrs_scroll_url';
      
      function saveScrollPosition() {
        const scrollY = document.documentElement.scrollTop || document.body.scrollTop || window.scrollY || 0;
        const currentUrl = location.href;
        if (scrollY > 0) {
          sessionStorage.setItem(STORAGE_KEY, String(scrollY));
          sessionStorage.setItem(URL_KEY, currentUrl);
        }
      }
      
      // Save on scroll with throttle for session persistence
      let saveTimeout;
      function throttledSave() {
        clearTimeout(saveTimeout);
        saveTimeout = setTimeout(saveScrollPosition, 100);
      }
      
      // Setup event listeners only for saving scroll position
      window.addEventListener('scroll', throttledSave, { passive: true });
      window.addEventListener('beforeunload', saveScrollPosition, { passive: true });
      window.addEventListener('pagehide', saveScrollPosition, { passive: true });
    })();
  </script>
  
  <!-- CRITICAL: Prevent white flash and scroll flash -->
  <style>
    html, body {
      background-color: #000000 !important;
      margin: 0 !important;
      padding: 0 !important;
      min-height: 100vh !important;
    }
    
    /* Basic styling */
    * {
      box-sizing: border-box;
    }
    
    /* Image defaults */
    img {
      max-width: 100%;
      height: auto;
      display: block;
    }
    
    /* Professional loading - content always visible */
    body {
      opacity: 1;
      background-color: #000000;
    }
    
    /* No hiding needed - instant scroll is fast enough to prevent flash */
    html.scroll-restored {
      /* Optional marker class for debugging */
    }
  </style>
  
  <!-- Favicon -->
  <link rel="icon" href="/favicon.svg" type="image/svg+xml" sizes="any">

  <!-- SEO Meta Tags -->
  <title>{title}</title>
  {description && <meta name="description" content={description} />}
  {keywords && <meta name="keywords" content={keywords} />}

  <!-- Performance & Caching Optimizations -->
  <meta http-equiv="Cache-Control" content="public, max-age=31536000, immutable" />
  <meta http-equiv="Permissions-Policy" content="accelerometer=(), camera=(), geolocation=(), gyroscope=(), magnetometer=(), microphone=(), payment=()" />
  <meta name="robots" content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1" />
  
  <!-- Resource Hints for Better Performance -->
  <link rel="preconnect" href="https://fonts.googleapis.com" crossorigin />
  <link rel="dns-prefetch" href="https://res.cloudinary.com" />
  <link rel="dns-prefetch" href="https://api.supabase.io" />
  <!-- Preconnect for external logo CDNs used in IntegrationsShowcase -->
  <link rel="preconnect" href="https://cdn.simpleicons.org" crossorigin />
  <link rel="preconnect" href="https://logo.clearbit.com" crossorigin />
  
  <!-- Aggressive prefetch likely next routes for instant navigation -->
  <link rel="prefetch" href="/contact/" />
  <link rel="prefetch" href="/contact" />
  
  <!-- Prefetch critical assets that might be needed -->
  <link rel="prefetch" href="/platform-dashboard-fullwidth.webp" />
  <link rel="prefetch" href="/sales-engine-dashboard.webp" />
  <link rel="prefetch" href="/marketing-engine-dashboard.webp" />
  
  <!-- Critical CSS will be inlined by Astro build process -->
  <link rel="modulepreload" href="/src/index.css" />

  <!-- Content Security Policy -->
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://static.hsappstatic.net https://plausible.io; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; img-src 'self' data: https:; media-src 'self' https://res.cloudinary.com; font-src 'self' data: https://fonts.googleapis.com https://fonts.gstatic.com; connect-src 'self' https: https://plausible.io; frame-src 'self' https://meetings-eu1.hubspot.com; object-src 'none'; base-uri 'self';" />

  <!-- Preconnect to external domains -->
  <link rel="preconnect" href="https://res.cloudinary.com" />
  <link rel="preconnect" href="https://plausible.io" crossorigin />

  <!-- Canonical URL -->
  <link rel="canonical" href={`https://buildrs.ai${Astro.url.pathname}`} />

  <!-- Open Graph -->
  <meta property="og:title" content={title} />
  {description && <meta property="og:description" content={description} />}
  <meta property="og:type" content="website" />
  <meta property="og:url" content={`https://buildrs.ai${Astro.url.pathname}`} />
  <meta property="og:image" content="https://buildrs.ai/hero-bg-buildrs-8k.webp" />
  <meta property="og:site_name" content="Buildrs" />

  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content={title} />
  {description && <meta name="twitter:description" content={description} />}
  <meta name="twitter:image" content="https://buildrs.ai/hero-bg-buildrs-8k.webp" />
  <meta name="twitter:site" content="@buildrs" />

  <!-- Structured Data -->
  {structuredData && <script type="application/ld+json" set:html={JSON.stringify(structuredData)}></script>}

  <!-- Plausible Analytics - Privacy-First Analytics -->
  <Analytics />

  <!-- View Transitions DISABLED - preventing scroll restoration conflicts -->
  <!-- <ViewTransitions /> -->

  <!-- Performance optimizations -->
  <link rel="dns-prefetch" href="//fonts.googleapis.com" />

  <!-- CRITICAL: Instant visibility - no FOUC -->
  <style>
    /* Essential instant paint - no delays, no opacity transitions */
    html, body {
      margin: 0;
      padding: 0;
      background-color: #000000;
      color: #ffffff;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Inter', system-ui, sans-serif;
      font-feature-settings: 'cv05' 1, 'kern' 1;
      text-rendering: optimizeLegibility;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      overflow-x: hidden;
    }
    
    /* Essential box model */
    *, *::before, *::after {
      box-sizing: border-box;
    }
    
    /* Main container - always black background with GPU acceleration */
    main {
      background-color: #000000;
      min-height: 100vh;
      transform: translateZ(0);
      will-change: auto;
    }
    
    /* Instant hero background visibility */
    section[class*="hero"] {
      background-color: #000000;
      min-height: 100vh;
    }
  </style>

  <!-- Glitch animations voor HomeAnimatedHeadline -->
  <style>
    .glitch-rgb-red { animation: glitch-rgb-red 120ms linear infinite; }
    .glitch-rgb-green { animation: glitch-rgb-green 120ms linear infinite; }
    .glitch-rgb-blue { animation: glitch-rgb-blue 120ms linear infinite; }
    .glitch-slice-1 { animation: glitch-slice-1 120ms linear infinite; }
    .glitch-slice-2 { animation: glitch-slice-2 120ms linear infinite; }
    .glitch-scanline { animation: glitch-scanline 120ms linear infinite; }

    @keyframes glitch-rgb-red {
      0% { transform: translate(-2px, -1px) skewX(-1deg); opacity: 0.8; }
      25% { transform: translate(1px, 2px) skewX(1deg); opacity: 0.9; }
      50% { transform: translate(-1px, 1px) skewX(-0.5deg); opacity: 0.7; }
      75% { transform: translate(2px, -2px) skewX(1.5deg); opacity: 0.8; }
      100% { transform: translate(-1px, 1px) skewX(0.5deg); opacity: 0.9; }
    }

    @keyframes glitch-rgb-green {
      0% { transform: translate(1px, -2px) skewY(1deg); opacity: 0.7; }
      25% { transform: translate(-2px, 1px) skewY(-1deg); opacity: 0.8; }
      50% { transform: translate(2px, 1px) skewY(0.5deg); opacity: 0.6; }
      75% { transform: translate(-1px, -2px) skewY(-1.5deg); opacity: 0.9; }
      100% { transform: translate(1px, 2px) skewY(1deg); opacity: 0.7; }
    }

    @keyframes glitch-rgb-blue {
      0% { transform: translate(2px, 1px) skewX(0.5deg); opacity: 0.9; }
      30% { transform: translate(-1px, -2px) skewX(-1deg); opacity: 0.6; }
      60% { transform: translate(3px, 1px) skewX(1.5deg); opacity: 0.8; }
      90% { transform: translate(-2px, -1px) skewX(-0.5deg); opacity: 0.7; }
      100% { transform: translate(1px, 2px) skewX(1deg); opacity: 0.8; }
    }

    @keyframes glitch-slice-1 {
      0% { transform: translateX(0px); }
      10% { transform: translateX(-5px) scaleX(1.05); }
      20% { transform: translateX(3px) scaleX(0.95); }
      30% { transform: translateX(-2px) scaleX(1.02); }
      40% { transform: translateX(4px) scaleX(0.98); }
      50% { transform: translateX(-3px) scaleX(1.03); }
      60% { transform: translateX(2px) scaleX(0.97); }
      70% { transform: translateX(-4px) scaleX(1.01); }
      80% { transform: translateX(3px) scaleX(0.99); }
      90% { transform: translateX(-1px) scaleX(1.02); }
      100% { transform: translateX(0px) scaleX(1); }
    }

    @keyframes glitch-slice-2 {
      0% { transform: translateX(0px); }
      15% { transform: translateX(4px) scaleX(0.96); }
      30% { transform: translateX(-3px) scaleX(1.04); }
      45% { transform: translateX(2px) scaleX(0.98); }
      60% { transform: translateX(-4px) scaleX(1.02); }
      75% { transform: translateX(3px) scaleX(0.97); }
      90% { transform: translateX(-1px) scaleX(1.01); }
      100% { transform: translateX(0px) scaleX(1); }
    }

    @keyframes glitch-scanline {
      0% { top: 0%; height: 2px; opacity: 0.8; }
      25% { top: 25%; height: 1px; opacity: 1; }
      50% { top: 50%; height: 3px; opacity: 0.6; }
      75% { top: 75%; height: 1px; opacity: 0.9; }
      100% { top: 100%; height: 2px; opacity: 0.7; }
    }
  </style>
</head>
<body class="min-h-screen bg-black text-white" style="margin: 0 !important; padding: 0 !important; height: 100% !important; position: relative !important; top: 0 !important;">
  <!-- ScailUp Navigation Header -->
  <ScailUpHeader client:load showAlways={true} />
  
  <slot />
  
  <!-- UTM Tracking Script - No cookies, localStorage only -->
  <TrackingScript />

  <!-- Scroll restoration is now handled in HEAD for immediate execution -->
</body>
</html>
